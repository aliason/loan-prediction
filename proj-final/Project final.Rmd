---
title: "Loan Prediction Machine Learning Project"
subtitle: "PSTAT 131 Final Project" 

author: "Alice Zhang"
date: "2023-03-24"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    df_print: paged
    theme: sandstone
    highlight: tango
    

---

```{r setup, include=FALSE}
library(knitr)   # to help with the knitting process
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(tidymodels)  # for modeling functions 
library(corrplot)
library(ggplot2)   # for most of our visualizations
library(ggthemes)
library(corrr)
library(dplyr)
library(plyr)
library(yardstick)  # metrics / metric set 
library(gridExtra)
library(naniar) # to assess missing data patterns
library(pROC)  # analyze ROC curves 
library(finalfit)
library(MASS)    # to assist with the markdown processes
library(dplyr)     # for basic r functions
library(discrim)  # discriminant analysis
library(klaR) # for naive Bayes
library(naniar)  # visualize missing data 
library(kableExtra)  
library(themis) # for upsampling
tidymodels_prefer()
options(scipen=999)  # remove scientific notation
```

# Introduction

This project aims to develop a machine learning model that predicts the loan eligibility of customers based on information provided in their application profile; a binary classification problem in which we predict whether a given loan would be approved or not. To this end, I will build, train, and evaluate several supervised learning models, using R data science libraries (tidymodels, ggplot, dplyr) to facilitate data analysis and modeling. 

Data are pulled from [Kaggle](https://www.kaggle.com/datasets/vikasukani/loan-eligible-dataset) (originally sourced from an [Analytics Vidhya Hackathon](https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/#ProblemStatement). 

## Problem Statement 
Loans are a necessity of the modern world, supporting consumption, economic growth, and business operations. Many types loans exist for different purposes across various stages of life, among which are home loans, which we intend to tackle in this problem. 

Dream Housing Finance company deals in all home loans. They have a presence across all urban, semi-urban and rural areas. Customers can apply for a home loan after the company validates their eligibility. The company wants to automate the loan eligibility process (real-time) based on customer detail provided in their application. The company wants to identify customer segments that are eligible for loan amounts so that they can specifically target these customers.

```{r echo=FALSE, out.width = "100%", fig.align = "center"}
knitr::include_graphics("~/Desktop/School/PSTAT/PSTAT 131/proj-final/images/image1.jpg")
```


## Dataset description 
The data files provided consists of a training set (train.csv) and test set (test.csv), which is identical to the training set except for the loan status to be predicted. The training set consists of 614 observations on 13 variables; the testing consists of 367 observations on 12. 

Since this project only employs supervised learning, I will use only the training set. I will be performing a 70/30 split on the train.csv and utilize the response values to evaluate predictive accuracy. 


## Project outline 
First, I will import the raw dataset and examine its records to determine the necessary data cleaning and transformations to be performed. I will then conduct exploratory data analysis to visualize relationships and covariability, report my findings, and perform final tidying of the dataset before setting up the models. I then split the train.csv into a train and test set (70/30) and create validation sets to facilitate model selection and tuning. Six classification models of varying flexibility and complexity are fit to the training set and evaluated based on multiple performance metrics; the top 3 are chosen for testing. Finally, I will analyze and interpret the results of the best models, followed by a detailed conclusion of my findings. 


# Exploratory Data Analysis
We begin by loading and examining the data and performing some initial data tidying and manipulation. We then utilize  visualization tools to explore the dataset and make some final adjustments before continuing with our analysis.  

## Loading the data
```{r, class.source = "fold-show", message=FALSE, warning=FALSE} 
loan_ds <- read.csv("~/Desktop/School/PSTAT/PSTAT 131/proj-final/project_data/train.csv")
str(loan_ds)
```

Observations: 
 
  * `Credit_History`, a factor, is encoded as numeric 
  * `Credit_History`, a categorical variable, is encoded as numeric. 
  * `ApplicantIncome` and `CoapplicantIncome` are monthly figures given in dollar amounts, while `LoanAmount` is given in terms of thousands. We ideally want these to be on the same scale. 

```{r}
colSums(is.na(loan_ds))  
```
We observe missingness in the (numeric) variables `LoanAmount`, `Loan_Amount_term` and `Credit_History`. Note that `is.na()` does not detect blank entries in character variables; thus, we must employ a different methodology to identify empty strings.

```{r}
sapply(loan_ds,function(x) table(as.character(x) =="")["TRUE"])
```
So we have blank entries in `Gender`, `Married`, `Dependents`, and `Self-employed`. We will first convert these blanks into NA's for easy identification and determine how to handle them at a later step. 


## Initial tidying

Reload the dataset; reading blank entries as "NA. 
```{r, class.source = "fold-show"}
loan_ds <- read.csv(file="~/Desktop/School/PSTAT/PSTAT 131/proj-final/project_data/train.csv",
                    header=TRUE,na.strings = c("",NA))   # read blanks as NA's 
```


Feature engineering: `ApplicantIncome` and `CoapplicantIncome` 

- Convert units into thousands of dollars to match that of `LoanAmount`.  

```{r, class.source = "fold-show"}
loan_ds$ApplicantIncome <- (loan_ds$ApplicantIncome)/1000
loan_ds$CoapplicantIncome <- (loan_ds$CoapplicantIncome)/1000
```

Redundancy

- Remove `Loan_ID`, a unique identifier, since it is not relevant to our analysis. 
```{r, class.source = "fold-show"}
loan_ds <- loan_ds[,-1]; colnames(loan_ds)
```


## Data transformation 

We convert categorical variables into factors. 

```{r, class.source = "fold-show"}
# convert categorical variables into factor 
loan_ds$Gender <- factor(loan_ds$Gender, levels = c("Male","Female"))
i <- factor(loan_ds$Married, levels = c("Yes","No"))
loan_ds$Education <- factor(loan_ds$Education, levels = c("Graduate","Not Graduate"))
loan_ds$Self_Employed <- factor(loan_ds$Self_Employed, levels = c("Yes","No"))
loan_ds$Property_Area <- factor(loan_ds$Property_Area, levels = c("Rural","Semiurban","Urban"))
loan_ds$Loan_Status <- factor(loan_ds$Loan_Status, levels = c("Y","N"), labels = c("Yes","No")) 
loan_ds$Credit_History <- factor(loan_ds$Credit_History, levels = c(1,0), labels = c("Yes","No"))  
loan_ds$Dependents <- recode(loan_ds$Dependents,"3+"="3") %>%
  as.factor()
loan_ds$Married <- factor(loan_ds$Married)
```



## Missing values

After transforming the data, we can now detect the correct amount of missingness in all variables. 
```{r}
colSums(is.na(loan_ds))
``` 

```{r, class.source = "show"}
vis_miss(loan_ds) # visualize missing data
```

The table below provides a numerical summary of missingness in our dataset, showing the number of missing values in each variable, percent of missingness, and cumulative sum of missingness (a running total). 
```{r}
missingness <- loan_ds %>%
  miss_var_summary(add_cumsum = TRUE) %>%
  dplyr::arrange(n_miss_cumsum) 

missingness
```

```{r}
sum(missingness$pct_miss)  # total % of missingness in dataset 
```

There are 149 total missing values (comprising ~24% of our dataset). One approach is to omit all missing values, or to remove variables with a lot of missingness. Another possible solution is to impute missing values where appropriate. Neither of these options are appropriate at this early of a stage in our analysis, since we do not yet know which variables are significant in prediction. 

We will leave the dataset as is for now and continue with exploratory data analysis before returning to address missing values at a later step. 


## Variable description

* `Loan_ID` : Unique Loan ID.
* `Gender` : Male / Female. 
* `Married` : Whether the applicant is married (Yes/No) 
* `Dependents` : A factor indicating the number of dependents an applicant has (0,1,2,3). 
* `Education` : An applicant's education level (Graduate/Under Graduate)
* `Self_Employed` : Whether the applicant is self-employed (Yes/No)
* `ApplicantIncome` : An applicant's monthly income (in thousands of dollars). 
* `CoapplicantIncome` : A coapplicant's monthly income (in thousands of dollars)
* `LoanAmount` : The loan amount requested by an applicant (in thousands of dollars). 
* `Loan_Amount_Term` : The term of the loan in months. 
* `Credit_History` : Does the applicant's credit history meet the bank's requirements (Yes/No)? 
* `Property_Area` : An applicant's area of residence (Urban/Semi Urban/Rural). 
* `Loan_Status` : Whether the loan was approved or not (Yes/No).



## Visual EDA 

This section consists of data exploration and visualization; we will first examine the response, generate a correlation matrix, and analyze the independent variables one by one to discern potential relationships. 

### Loan Status 
First, we will look at the distribution of the response by creating a barplot.
```{r}
loan_ds %>% 
  ggplot(aes(x = Loan_Status)) +
  geom_bar() + 
  theme_grey()  # create barplot 
```

```{r}
loan_ds %>%
  select(Loan_Status) %>%
  table() %>%
  prop.table() 
```

Approximately 69% of applicants were approved while 31% were rejected. This imbalance in classes may hinder our models' ability to generate accurate predictions for`Loan_Status`. We will likely need to  *upsample* or *downsample* the data at a later step. 


### Correlation plot
Examining dependency among independent variables is a crucial step in our analysis, providing insight into relationships, interactions, and potential issues such as multicolinearity. 

The `corrplot()` function generates a graphical display of a correlation matrix, where the main diagonal are variances and the other cells are covariances. The sliding scale on the right-side of the plot illustrates the strength and direction of relationships for each pair. Note that `corrplot()` only accepts numeric variables. 

```{r, echo=FALSE, messages=FALSE, warnings=FALSE}
loan_ds %>%
  select(where(is.numeric)) %>%  # generate heatmap of numeric variables 
  na.omit() %>%  
  cor() %>%
  corrplot()
```

The plot below illustrates the magnitude of correlation coefficients. 
```{r}
loan_ds %>%
  select(where(is.numeric)) %>%
  na.omit() %>%  
  cor() %>%
  corrplot(method="number")
```

We observe a moderate, positive correlation between `LoanAmount` and `ApplicantIncome` (0.57), and very little correlation (+/- 0.20) among the other numeric predictors (a good sign!). We will keep these findings in mind as we explore the dataset. 

In the next few sections, we will analyze our predictors one-by-one to examine their distribution and relationship with each other and the response. 


### Loan Amount

We observe a right-skewed distribution, with most values falling between 0-400 thousand; a good insight into the average amount requested by each applicant. We also detect a few high outliers pulling the mean up. There is no significant variation between the average loan amounts requested by approved  and rejected applicants; however, we see greater variation among the rejected applicants. 
```{r}
require(gridExtra)

plot1 <- loan_ds %>%
  na.omit(LoanAmount) %>%
  ggplot(aes(x=LoanAmount)) + 
  geom_histogram(bins=40) +
  theme_grey()

plot2 <- loan_ds %>%
  na.omit(LoanAmount) %>%
  ggplot(aes(Loan_Status, LoanAmount)) + 
  geom_boxplot(na.rm=T) +
  geom_jitter(alpha = 0.1) +
  theme_grey()

grid.arrange(plot1, plot2, ncol=2)
```
```{r}
anova(aov(LoanAmount ~ Loan_Status, loan_ds))  # insignificant difference 
``` 

Recall that `LoanAmount` is positively correlated with `Applicant_Income`. A plot of `LoanAmount` by `ApplicantIncome` shows an approximately linear trend, indicating that applicants with higher income tend to request larger loans. 
```{r, echo=FALSE}
plot1 <- loan_ds %>%
  na.omit(LoanAmount) %>% 
  ggplot(aes(y=LoanAmount, x=ApplicantIncome)) +
  geom_point() 

plot2 <- loan_ds %>%
  na.omit(LoanAmount) %>% 
  ggplot(aes(y=LoanAmount, x=ApplicantIncome, fill=Loan_Status,color=Loan_Status)) +
  geom_point() +
  theme_grey()

# we should take a closer look at applicant income
grid.arrange(plot1, plot2, ncol=2)
```
When stratifying applicants based on `Loan_Status`, we observe similar approval rates across different loan amounts. However, it is difficult to discern whether applicant incomes are predictive of loan status. This brings us to our next section. 



### Applicant Income 

Applicant monthly incomes range from 0.15 to 81 thousand dollars, with the majority of values falling between 5 and 7 thousand. 
```{r}
summary(loan_ds$ApplicantIncome)
``` 

We observe a right-skewed distribution; even with extreme outliers omitted, there's a still an imbalance in the proportion of applicants falling within each income range. Average incomes among approved and rejected applicants are about the same. 
```{r}
plot1 <- loan_ds %>%
  filter(ApplicantIncome < 50) %>%    # omit high outliers 
  ggplot(aes(x=ApplicantIncome)) + 
  geom_histogram(fill="bisque",color="white",alpha=0.7, bins=10) + 
  geom_density() +
  geom_rug() + 
  labs(x = "applicant income") +
  theme_minimal()

plot2 <- loan_ds %>%
  filter(ApplicantIncome < 50) %>%  
  ggplot(aes(y=ApplicantIncome,x=Loan_Status, color=Loan_Status))+
  geom_boxplot() +
  theme_grey()

grid.arrange(plot1, plot2, ncol=2)
```

Upon inspecting the three high outliers (`ApplicantIncome` > 50), we find that: 

- 2 out of 3 applicants have 3 or more dependents, both of whom are self-employed;

- 2 out of 3 applicants were approved for a loan; both reside in an urban area and have good credit history.

- 2 out of 3 applicants are Males; 

- All 3 applicants have a graduate degree and have no coapplicant. 

```{r}
loan_ds %>%
  filter(ApplicantIncome > 50)
```

These observations indicate that neither `ApplicantIncome` or `LoanAmount` are not very predictive of `Loan_Status` in the most extreme cases, seeing that, the most affluent applicant requesting the smallest amount was rejected. In theory, we'd expect the opposite outcome. 

We also observe that `Property_Area` and `Credit_History` are relevant factors even in applicants with very high incomes, seeing as the only applicant who was rejected resides in a rural area and has bad credit history. 

It's difficult to discern whether `Education` or `Dependents` affect loan status; we will examine these factors in the next sections. 

For now, let's take a closer look at approval rates. Applicants with monthly incomes of 15-20 thousand have the highest approval rate of ~77%. So, higher income do somewhat translate to a higher approval rate. However, we must note that there are varying amounts of data points in each bin, possibly inflating (or understating) approval rates. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
loan_ds %>%
  filter(ApplicantIncome < 50) %>%  
  dplyr::mutate(bin = cut(ApplicantIncome, breaks=c(0, 5, 10, 15, 20, 25))) %>%
  group_by(bin, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
```



### Coapplicant Income

A density plot grouped by `Loan_Status` indicates that coapplicant incomes are right skewed, with a mix of high and low values in each status category. Average coapplicant incomes for approved applicants are slightly higher than that of rejected applicants. 

```{r, echo=FALSE}
loan_ds %>%
  filter(CoapplicantIncome < 30) %>%  # omit high outliers
  ggplot(aes(x=CoapplicantIncome)) + 
  geom_histogram(fill="bisque",color="white",alpha=0.7, bins=20) + 
  geom_density() +
  geom_rug() + 
  labs(x = "Coapplicant Income") + 
  facet_wrap(~Loan_Status)  +   
  theme_minimal() 
```

```{r}
loan_ds %>%
  ggplot(aes(x=Loan_Status, y=CoapplicantIncome, color=Loan_Status)) + 
  geom_boxplot()
```


It is important to note that many coapplicant incomes are 0 (no coapplicant) across both categories, skewing the mean down significantly. Omitting those values provide us with better insight into its central tendency. The below plot suggests a different conclusion that what we assumed previously. Of those with a coapplicant, applicants are approximately equally likely of being approved for a loan. 
```{r}
loan_ds %>%
  filter(CoapplicantIncome != 0) %>% 
  ggplot(aes(x=Loan_Status, y=CoapplicantIncome, color=Loan_Status)) + 
  geom_boxplot()
```

Next, we examine whether having a coapplicant itself affects loan status. The table below shows that 273 out of 614 (about 44%) applicants do not have a coapplicant; a relatively large count. 

```{r, message=FALSE, warning=FALSE}
loan_ds %>%
  dplyr :: count(CoapplicantIncome == 0) 
```

The variable `has_coapp` has the value of FALSE if `CoapplicantIncome` is 0, and TRUE otherwise. A contingency table of `Loan_Status` and `has_coapp` indicates that applicants with coapplicants are more likely to be approved (71% vs 65%). 
```{r, message=FALSE, warning=FALSE} 
loan_ds %>%
  dplyr:: mutate(has_coapp = if_else(CoapplicantIncome != 0,TRUE,FALSE)) %>%
  group_by(has_coapp, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
# on average, ~72% of applicants w/ a coapplicant were approved for a loan
# while only ~65% of applicants w/o a coapplicant were approved.
```

Perhaps the presence of a coapplicant is more predictive of loan status than the numerical value of their income. We should consider transforming `CoapplicantIncome` into a factor.


### Loan amount term

`Loan_Amount_Term` gives the term of the loan in months. From the plot below, we see that it has a left skew. This means that its mean (342 months ie., 28.5 years) is lower than its median and mode. Because there are so few points on the lower end, the mode is more representative of its center.
```{r}
loan_ds %>%
  na.omit(Loan_Amount_Term) %>%
  ggplot(aes(x=Loan_Amount_Term)) + 
  geom_bar() +
  theme_grey() # mfv 360 
```


We now look at `Loan_Amount_Term` in relation to `Loan_Status` Applicants requesting short-term loans are more likely to be approved, on average, but we do see a high approval rate for 360. We should also keep in mind that ~85% of loans have a term of 360; the data may be under-representing applicants with alternative loan terms.
```{r}
loan_ds %>%
  na.omit(Loan_Amount_Term) %>%  
  ggplot(aes(x=Loan_Amount_Term, fill=Loan_Status)) + 
  geom_bar(position="fill")
```



### Dependents

Dependents is right skewed; most applicants have no dependents. Approval rates are similar across each category, with the highest approval rate for 2 dependents. There is no clear pattern; this indicates that `Dependents` may not be very influential in determining their `Loan_Status`.
```{r}
plot1<-loan_ds %>%
  na.omit(Dependents) %>%  # should be able to impute this later
  ggplot(aes(x=Dependents)) +
  geom_bar()  # most applicants have no dependents

# dependents vs. loan status
plot2<-loan_ds %>%
  na.omit(Dependents) %>%  
  ggplot(aes(x=Dependents, fill=Loan_Status)) + 
  geom_bar(position="fill")
# relatively similar likelihood of approval for each # of dependents

grid.arrange(plot1,plot2,ncol=2)
```

A natural question is whether applicants with dependents (indicative of a larger household) request a larger loan. The boxplots below indeed suggest that individuals with dependents do, on average, request a larger loan amount; however, the actual number of dependents do not seem very significant. 
```{r, echo=FALSE}
loan_ds %>%
  na.omit(Dependents,LoanAmount) %>%  
  ggplot(aes(x=LoanAmount, y=Dependents, group=Dependents, fill=Dependents)) + 
  geom_boxplot()
```




### Gender

We observe there are more male applicants than female applicants (81% vs 19%); thus females may be under represented. A natural question to ask is whether there is bias in the selection process. From the plots below, we can see that females are indeed less likely (about 8%) to be approved for a loan than males.

```{r, message=FALSE, warning=FALSE}
prop.table(table(loan_ds$Gender))  # more males than females 
```

```{r}
loan_ds %>%
  na.omit(Gender) %>%  # should be able to impute this later
  ggplot(aes(x=Gender, fill=Loan_Status)) + 
  geom_bar(position="fill")
```

```{r}
# 2-way contingency table 
loan_ds %>%
  na.omit(Gender) %>%
  group_by(Gender, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
```



### Married

Married applicants comprise a majority of our dataset (~60%), which is surprising since most applicants have no dependents. Nonetheless, a 60-40 ratio offers a good contrast. Those who are married are 10% more likely to be approved for a loan - a pretty significant difference given the size of our dataset. 

```{r, message=FALSE, warning=FALSE}
prop.table(table(loan_ds$Married))
```

```{R}
loan_ds %>%
  na.omit(Married) %>%
  ggplot(aes(x=Married,fill=Loan_Status)) +
  geom_bar(position="fill")
```

```{r} 
# 2-way contingency table 
loan_ds %>%
  na.omit(Married) %>%
  group_by(Married, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
```



### Education
`Education` is a factor representing an applicant's educational level with levels "Graduate" or "Not Graduate". Our dataset is comprised of ~80% graduates, which makes sense due to education loans. An 80-20 ratio, however, is definitely unbalanced. From the barplots, we can see that graduates are more likely to get approved (8% more). 
```{r, message=FALSE, warning=FALSE}
prop.table(table(loan_ds$Education))
```

```{r}
loan_ds %>%
  na.omit(Education) %>%
  ggplot(aes(x=Education,fill=Loan_Status)) +
  geom_bar(position="fill")
```

```{r}
# 2-way contingency table 
loan_ds %>%
  na.omit(Education) %>%
  group_by(Education, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
```



### Self employed
`Self_Employed` is a factor that indicates if an applicant is self-employed. Only 14% of applicants in the dataset are self-employed. There is no significant difference in the approval rates between self-employed and non self-employed individuals; a slight difference of 4%, with non self-employed individuals having the higher rate.
```{r,message=FALSE, warning=FALSE}
prop.table(table(loan_ds$Self_Employed))
```

```{r}
loan_ds %>%
  na.omit(Self_Employed) %>%
  ggplot(aes(x=Self_Employed,fill=Loan_Status)) +
  geom_bar(position="fill")
```

```{r}
# 2-way contingency table 
loan_ds %>%
  na.omit(Self_Employed) %>%
  group_by(Self_Employed, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
```



### Credit History

`Credit_History` is a factor indicating whether an applicant's credit satisfies the bank's requirements. Most applicants do have good credit history (~85%). Credit history appears to be a very important factor, given that nearly 80% of applicants with good credit history get approved, whereas only 10% of applicants with bad credit history do. It is important to note, however, that there may be some selection bias since individuals with good credit history may be more inclined to apply in the first place.

```{r, message=FALSE, warning=FALSE}
prop.table(table(loan_ds$Credit_History))
```

```{r}
loan_ds %>%
  na.omit(Credit_History) %>%
  ggplot(aes(x=Credit_History,fill=Loan_Status)) +
  geom_bar(position="fill")
```

```{r}
# 2-way contingency table 
loan_ds %>%
  na.omit(Credit_History) %>%
  group_by(Credit_History, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
```




### Property Area
`Property_Area` is a factor representing the area in which an applicant resides: Urban, Semi Urban, or Rural. We have a  good mix of applicants from all 3 areas; those residing in semi urban areas have the highest approval rate. We also observe that married individuals tend to prefer semi urban areas over others. This is a pretty insightful finding because, as we recall, married individuals had a 10% higher approval rate than non-married individuals. Coupled with a higher approval rate for those with coapplicants, we may just find our target demographic!

```{r, message=FALSE, warning=FALSE}
prop.table(table(loan_ds$Property_Area))
```

```{r}
loan_ds %>%
  na.omit(Property_Area) %>%
  ggplot(aes(x=Property_Area,fill=Loan_Status)) +
  geom_bar(position="fill")
```

```{r}
# 2-way contingency table 
loan_ds %>%
  na.omit(Property_Area) %>%
  group_by(Property_Area, Loan_Status) %>% 
  dplyr:: summarise(n=n()) %>%
  dplyr::mutate(freq = prop.table(n))  
```

```{r}
# is property area related to any other predictors?
loan_ds %>%
  na.omit(Property_Area, Loan_Status, Married) %>%
  dplyr:: mutate(has_coapp = if_else(CoapplicantIncome != 0,TRUE,FALSE)) %>%
  ggplot(aes(x=Property_Area,fill=Married)) +
  geom_bar(position="dodge") +
  facet_wrap(~has_coapp)
```




## Final tidying

Now that we've explored the dataset, we will need to fix some errors before continuing with our analysis. Let's review these issues:

- Missingness observed in 7 variables; 

- Extreme high outliers observed in `ApplicantIncome` and `LoanAmount`. 


### MICE 
Missingness exists in both numerical and categorical variables. Therefore, we will be using the `mice` package, which imputes missing values with plausible data values inferred from other variables in the dataset. 

```{r, class.source = "fold-show", message=FALSE, warning=FALSE}
# install and load 
# install.packages("mice")
library(mice)
```

From the missing data table below, we see that the first two variables are missing a large proportion of its values, while the latter five are missing none. 
```{r, message=FALSE, warning=FALSE}
loan_ds %>%
  miss_var_summary()
```


Now, we call the `mice` package. The argument `m` indicates the number of multiple imputations; the standard is m = 5. The `method` argument specifies the imputation method applied to all variables in the dataset; a separate method can also be specified for each variable. 

We can control the `defaultMethod` used for different types of data. I will choose predictive mean matching for numeric data, logistic regression for 2-level factors, linear discriminant analysis for unordered factor data, and proportional odds for ordered factor data.


```{r, class.source = "fold-show", message=FALSE, warning=FALSE, results=FALSE}
imp <- mice(loan_ds, m=5, defautMethod = c("pmm","logreg", "lda", "polr"))
```


Here, we can see the actual imputations for `Dependents`: 
```{r, class.source = "fold-show",} 
imp$imp$Dependents
```


Now let's merge the imputed data into our original dataset via the `complete()` function.
```{r, class.source = "fold-show"} 
loan_ds <- complete(imp,5)  # I chose the 5th round of data imputation
```

Check missing data again, we note that there is no missing data after the imputation:
```{r, class.source = "fold-show", message=FALSE, warning=FALSE}
loan_ds %>%
  miss_var_summary()
```




### Outliers

Outliers can be tricky. It's hard to determine if they are data entry errors, sampling errors, or natural variation in our data. If we decide to remove records, however, it may result in information loss. We will assume that the missing values are systematic until proven otherwise. 


Looking at `LoanAmount`, we see that the "extreme" values are somewhat plausible. Some customers may want to apply for a loan as high as 650 thousand.

```{r, message=FALSE, warning=FALSE}
zscore <- (abs(loan_ds$LoanAmount-mean(loan_ds$LoanAmount, na.rm=T))/sd(loan_ds$LoanAmount, na.rm=T))
loan_ds$LoanAmount[which(zscore > 3)]
```

Since we have a positive skew, we will perform a log transformation to normalize the data. Now the data looks closer to normal and the effect of extreme outliers are significantly smaller.
```{r,class.source = "fold-show"} 
loan_ds$LogLoanAmount <- log(loan_ds$LoanAmount)
```

```{r}
plot1 <- loan_ds %>% 
  ggplot(aes(x=LoanAmount)) +
  geom_histogram(bins=20) +
  geom_density()+
  labs(title="Histogram for Loan Amount") +
  xlab("Loan Amount") 

plot2 <- loan_ds %>% 
  ggplot(aes(x=LogLoanAmount)) +
  geom_histogram(bins=20) +
  geom_density()+
  labs(title="Histogram for Log Loan Amount") +
  xlab("Log Loan Amount") 

grid.arrange(plot1,plot2,ncol=2)
```


We also have a pretty severe positive skew for `ApplicantIncome`, so we will perform a log transformation as well. The data looks much better. 
```{r,class.source = "fold-show"} 
loan_ds$LogApplicantIncome <- log(loan_ds$ApplicantIncome)
```

```{r}
plot1 <- loan_ds %>% 
  ggplot(aes(x=ApplicantIncome)) +
  geom_histogram(bins=20) +
  geom_density()+
  labs(title="Histogram for Applicant Income") +
  xlab("Applicant Income") 

plot2 <- loan_ds %>% 
  ggplot(aes(x=LogApplicantIncome)) +
  geom_histogram(bins=20) +
  geom_density()+
  labs(title="Histogram for Log Applicant Income") +
  xlab("Log Applicant Income") 

grid.arrange(plot1,plot2,ncol=2)
```


Now, we will remove the original variables from our dataset
```{r,class.source = "fold-show"} 
loan_ds <- select(loan_ds,-LoanAmount)  # remove original variable
loan_ds <- select(loan_ds,-ApplicantIncome)  # remove original variable 
```




# Setting Up Models

Now that we have a better idea of how the variables in our dataset impact loan status, it's time to set up our models. We will perform our train/test split, create our recipe, then establish 10-fold cross-validation to help with our models. 


## Train/test split

Before we do any modeling, we will need to randomly split our dataset into a train and test set. The reason why we split our data is to avoid overfitting; we will fit the models on the training data, then use those models to make predictions on the previously unseen testing data. The testing set is reserved to be fit only once *after* the models have "learned" from the train set. From there, we will use error metrics to evaluate each model's performance. We will use a 70/30 split since our dataset is relatively small and we want to reserve enough data for the test set. We will set a random seed before our split so that we can replicate our results, and stratify on our response.  

```{r,class.source = "fold-show"} 
set.seed(3450)
loan_split <- initial_split(loan_ds, prop = 0.70, 
                              strata = "Loan_Status")

loan_train <- training(loan_split)
loan_test <- testing(loan_split)
loan_folds <- vfold_cv(loan_train, v = 10, strata = "Loan_Status")
```

Dimensions of our datasets:
```{r,class.source = "fold-show"} 
dim(loan_train); dim(loan_test)
```



## Building the recipe

Now that we've completed all the preliminary steps, it's time to build our recipe. Think of it as following a recipe for cut-out cookies. Because we'll be using a variety of different molds (models), each cookie will look different, but their ingredients will be the same! Inside, they're all the same flour and sugar and eggs! That's what this recipe is; a unique mix of ingredients that will be fitted to different molds. Our goal turns into finding the best mold for our particular mix. From there, fitting the best model to our test data is analogous to using a different brand of the essential ingredients (ie., the test data), shaping the dough with our best cookie mold, then putting it into the oven! 

In our recipe, we'll be using 8 out of the 11 original predictors, 2 transformed variables `LogLoanAmount` and `LogApplicantIncome`, plus a new variable `Coapplicant`. 


We'll first need to upsample the data. Recall from earlier that our response was severely imbalanced; if we train our models on an imbalanced dataset, they can accidentally become better at identifying one level versus another, which is undesirable. Two solutions come to mind: upsampling or downsampling. Since we have a small dataset, `step_upsample()` is the better option. We'll use `over_ratio=1` so that are equally as many Yes's as there are No's. Because upsampling is intended to be performed on the training set alone, the default skip option is `skip=TRUE`. We'll use `skip=FALSE` to make sure that it's brought the counts to be equal and then rewrite the recipe without. 

Since the values of `CoapplicantIncome` do not appear to affect our response, we'll transform it into a categorical variable `Coappliant` to indicate the presence or absence of a coapplicant. We'll then scale and center our numeric predictors, and dummy-code the nominal predictors. 

```{r,class.source = "fold-show"} 
loan_recipe <- recipe(Loan_Status~., data=loan_train) %>%
  step_upsample(Loan_Status, over_ratio = 1, skip = FALSE) %>% 
  step_mutate(Coapplicant = factor(if_else(CoapplicantIncome!=0, "Yes","No",NA))) %>%
  step_rm(CoapplicantIncome)  %>% 
    # transform coapplicant income into a factor
    # Yes if CoapplicantIncome is not 0, No otherwise. 
  step_scale(all_numeric_predictors()) %>%
  step_center(all_numeric_predictors()) %>%  # scale and center
  step_dummy(all_nominal_predictors())    # convert into factor 
```

```{r,class.source = "fold-show"} 
prep(loan_recipe) %>% bake(new_data = loan_train) %>% 
  group_by(Loan_Status) %>% 
  dplyr :: summarise(count = n())
```


Now we rewrite the recipe with `skip=TRUE`:
```{r,class.source = "fold-show"} 
loan_recipe <- recipe(Loan_Status~., data=loan_train) %>%
  step_upsample(Loan_Status, over_ratio = 1, skip = TRUE) %>% 
  step_mutate(Coapplicant = factor(if_else(CoapplicantIncome!=0, "Yes","No",NA))) %>%
  step_rm(CoapplicantIncome)  %>% 
    # transform coapplicant income into a factor
    # Yes if CoapplicantIncome is not 0, No otherwise. 
  step_scale(all_numeric_predictors()) %>%
  step_center(all_numeric_predictors()) %>%  # scale and center
  step_dummy(all_nominal_predictors())    # convert into factor 
```


We can use `prep()` to check the recipe to verify it worked. 

```{r,class.source = "fold-show"} 
prep(loan_recipe) %>% 
  bake(new_data = loan_train) %>% 
  kable() %>% 
  kable_styling(full_width = F) %>% 
  scroll_box(width = "100%", height = "200px")
```

Notice that, by dummy-coding the nominal predictors, we've increased the number of columns in our dataset. This is because each factor has been transformed into k-1 dummy variables, with one level held out as the reference (or baseline) level. The baseline level is not visible in our dataset and assigned a value of 0. For a given predictor, if the dummy variables corresponding to every other level is 0, then we default to the baseline. For instance both `Property_Area_Urban` and `Property_Area_Semiurban` are 0, then the applicant must be from a Rural area.



## K-fold cross-validation

We will stratify on our response variable `Loan_Status` and use 10 folds to perform stratified cross validation. K-fold cross-validation divides our data into k folds of roughly equal sizes, holds out the first fold as a validation set, and fits the model on the remaining k-1 folds as if they were the training set. This is repeated k times; each time, a different fold is used as a validation set. This results in k estimates of the test MSE (or in the classification case, test error rate).

```{r,class.source = "fold-show"} 
loan_folds <- vfold_cv(loan_train, v = 10, strata = Loan_Status)
```

To save computational time, we will save the results to an RDA file; once we have the model we want, we can go and load it later with no time commitment. 

```{r,class.source = "fold-show"} 
save(loan_ds, loan_folds, loan_recipe, loan_train, loan_test, 
     file = "~/Desktop/School/PSTAT/PSTAT 131/proj-final/rda_files/loan-setup.rda")
```




# Model Building

It's time to build our models! For ease of efficiency and access, I will be building each model in a separate R file and saving my results in RDA files. The models will then be loaded below for further exploration. This allows us to streamline our analysis and save on computational time. 

For each model, we will: 

  1. Set up the model by specifying its type, engine, and mode.  
  2. Set up the workflow; add the model and defined recipe. 
  
For models requiring parameter tuning, we'll complete steps 3-5. 
  
  3. Use `grid_regular` to set up tuning grids of values for the parameters we're tuning and specify levels for each.
  4. Fit the models to our folded data via `tune_grid()`.
  5. Select the best value(s) of the parameter(s) based on `roc_auc` and finalize the workflow. 
  6. Fit the final model to entire training set. 
  7. Save results to RDA file. 
  

Afterwards, we'll load back in the saved files, collect error metrics, and analyze their individual performances.



## Error metric 

The performance metric we'll be using is `roc_auc`, which stands for area under the ROC curve. The ROC (receiver operating characteristics) curve is a popular graphic that plots true positive rate (TPR) vs. false positive rate (FPR) at various threshold settings. TPR is *sensitivity* (proportion of observations that are correctly classified), while FPR is *1-specificity* (proportion of observations that are incorrectly classified); the higher the TPR, the better. The AUC (area under curve) is a measure of the diagnostic ability of a classifier, highlighting the trade-off between sensitivity and specificity. 


```{r echo=FALSE, out.width = "100%", fig.align = "center"}
knitr::include_graphics("~/Desktop/School/PSTAT/PSTAT 131/proj-final/images/image2.jpg")
```





# Model Evaluation  

It's time to load our models back in to evaluate their results! 

```{r, class.source="show"}
load(file= "~/Desktop/School/PSTAT/PSTAT 131/proj-final/rda_files/logistic.rda")
load(file= "~/Desktop/School/PSTAT/PSTAT 131/proj-final/rda_files/knn.rda")
load(file= "~/Desktop/School/PSTAT/PSTAT 131/proj-final/rda_files/en.rda")
load(file= "~/Desktop/School/PSTAT/PSTAT 131/proj-final/rda_files/lda.rda")
load(file= "~/Desktop/School/PSTAT/PSTAT 131/proj-final/rda_files/qda.rda")
load(file= "~/Desktop/School/PSTAT/PSTAT 131/proj-final/rda_files/decision-tree.rda")
```


## Model autoplots 

Here, we will visualize the results of our tuned models. We will use the `autoplot` function to visualize the effect of varying select parameters on the performance of each model according to its impact on our metric of choice. 


### K-nearest neighbors 

For the KNN model, we had 10 different levels of `neighbors`. In general, the higher the number of `neighbors`, the greater the `roc_auc`. The `roc_auc` score of the best performing model (k=10) is approximately 0.71, which is pretty decent. 
```{r, class.source="show"}
autoplot(knn_tune_res)
```


### Elastic net
In our elastic net model, we tuned 2 parameters with 10 levels of each: `penalty`, the amount of regularization, and `mixture`, the proportion of lasso penalty (1 for pure lasso, 0 for pure ridge). We can see from the graph that the optimal mixture was 0 (pure ridge). Lower levels of mixture resulted in higher `roc_auc` scores, and that models performed worse as `penalty` (amount of regularization) increased. 
```{r, class.source="show", warning=FALSE, message=FALSE}
autoplot(en_tune_res)
```
In our elastic net model, we tuned 2 parameters with 10 levels of each: `penalty`, the amount of regularization, and `mixture`, the proportion of lasso penalty (amount of regularization). 

### Decision tree

For our decision tree model, we focused on the parameter `cost_complexity` and tuned it with 10 levels. Oftentimes decision trees can have too many splits, leading to a very complex model that is likely to overfit the data. A smaller tree with fewer splits can address this issue by yielding a simpler model (better interpretation, more bias).

The idea of cost-complexity pruning is similar to that of lasso / ridge regularization: first, we grow a very large tree, then consider a sequenced of pruned sub-trees and select the one that minimizes a penalized error metric. The tuning parameter `cost_complexity` controls a trade-off between a subtree's complexity and its fit to the training data; when `cost_complexity` is 0, it's the same as the the training error rate; as `cost_complexity` increases, the tree is penalized for having too many nodes. 


We can see from the plot below that a cost-complexity of about 0.25 yields the optimal model (with highest `roc_auc`). This indicates that pruning was a correct choice. Note that the parameter uses the `log10_trans()` functions by default, so all of the values in our grid are in the log10 scale. 

```{r, class.source="show"}
autoplot(dt_tune_res)
```



## Model selection

Here, we will compare the performance of each model on the training data and create visualization. I've created a tibble in order to display the estimated testing `roc_auc` scores for each fitted model. 

```{r}
log_auc <- augment(log_fit, new_data = loan_train) %>%
  roc_auc(truth = Loan_Status, .pred_Yes) %>%
  select(.estimate)

lda_auc <- augment(lda_fit, new_data = loan_train) %>%
  roc_auc(truth = Loan_Status, .pred_Yes) %>%
  select(.estimate)

qda_auc <- augment(qda_fit, new_data = loan_train) %>%
  roc_auc(truth = Loan_Status, .pred_Yes) %>%
  select(.estimate)

knn_auc <- augment(knn_final_fit, new_data = loan_train) %>%
  roc_auc(truth = Loan_Status, .pred_Yes) %>%
  select(.estimate)

en_auc <- augment(en_final_fit, new_data = loan_train) %>%
  roc_auc(truth = Loan_Status, .pred_Yes) %>%
  select(.estimate)

dt_auc <- augment(dt_final_fit, new_data = loan_train) %>%
  roc_auc(truth = Loan_Status, .pred_Yes) %>%
  select(.estimate)



roc_aucs <- c(log_auc$.estimate,
                           lda_auc$.estimate,
                           qda_auc$.estimate,
                           knn_auc$.estimate,
                           en_auc$.estimate,
                           dt_auc$.estimate)

mod_names <- c("Logistic Regression",
            "LDA",
            "QDA",
            "KNN",
            "Elastic Net",
            "Decision Tree")
```


```{r}
mod_results <- tibble(Model = mod_names,
                             ROC_AUC = roc_aucs)

mod_results <- mod_results %>% 
  dplyr::arrange(-roc_aucs)

mod_results
```

While all of our models performed well, the best-performing model is the KNN model with an `roc_auc` score of 0.94, with the QDA model close behind at 0.86. I've created a lollipop plot below to help visualize these results. 

```{r}
lp_plot <- ggplot(mod_results, aes(x = Model, y = ROC_AUC)) + 
    geom_segment( aes(x = Model, xend = 0, y = ROC_AUC, yend = 0)) +
  geom_point( size=7, color= "black", fill = alpha("blue", 0.3), alpha=0.7, shape=21, stroke=3) +
  labs(title = "Model Results") + 
  theme_minimal()

lp_plot
```



# Results of the Best Models

Now that we've identified our best models, we can continue to further analyze their true performance. We will start with the KNN model and also analyze the performance of the decision tree and QDA model as a means of comparison. 


## KNN model 

### Performance on the folds

So, the KNN model performed the best overall, but which of value of `neighbors` yields the best performance?
```{r, class.source = "show"}
# select metrics of best knn model
knn_tune_res %>% 
  collect_metrics() %>% 
  dplyr::arrange(mean) %>% 
  slice(10)
```
KNN model # 10 with 11 predictors, 10 neighbors, and a mean `roc_auc` score of 69 performed the best! Now that we have our best model, we can fit it to our testing data to explore its true predictive power. 


### Testing the model

Despite performing well on the training set, the KNN model performed poorly on our test data. In general, an AUC value between 0.7-0.8 is considered acceptable; the KNN models falls 0.2 points short of the lower boundary. 

```{r}
knn10_roc_auc <- augment(knn_final_fit, new_data = loan_test) %>%
  roc_auc(Loan_Status, .pred_Yes)  %>%
  select(.estimate)

knn10_roc_auc 
```



### ROC curve 

Below is a confusion matrix of the test results as well as an ROC/AUC plot. 
```{r}
knn_test_results <- augment(knn_final_fit, new_data = loan_test)

knn_test_results %>% 
  conf_mat(truth = Loan_Status, estimate = .pred_class) %>% 
  autoplot(type = "heatmap")
```

```{r, warning=FALSE}
knn_test_results %>% 
  roc_curve(Loan_Status, .pred_Yes) %>%
  autoplot()
```

In general, the more an ROC curve resembles the top left angle of a square, the better the AUC. While our curve is not perfect, it has the correct shape and looks pretty decent.


Here's a distribution of the predicted probabilities. 
```{r, message=FALSE}
knn_test_results %>% 
  ggplot(aes(x = .pred_Yes, fill = Loan_Status)) + 
  geom_histogram(position = "dodge") + theme_bw() +
  xlab("Probability of Yes") +
  scale_fill_manual(values = c("blue", "orange"))
```



## QDA

Now, it's time to analyze our quadratic discriminant analysis (QDA) classifier. In short, it's a more advanced version of a LDA model used to find a non-linear decision boundaries between classifiers, assuming each class follows a Gaussian distribution. 



### Testing the model

To my surprise, the QDA model performed better than the KNN model, though its computed `roc_auc` score is only slightly higher. Nevertheless, a 0.02 point increase is very significant when it comes to AUC. 
```{r}
qda_roc_auc <- augment(qda_fit, new_data = loan_test, type = 'prob') %>%
  roc_auc(Loan_Status, .pred_Yes) %>%
  select(.estimate)

qda_roc_auc
```

### ROC curve

Instead of fluctuating between concavity and convexity (in the case of KNN), the QDA model's ROC curve is consistently concave; definitely an improvement. 

```{r}
augment(qda_fit, new_data = loan_test, type = 'prob') %>%
  roc_curve(Loan_Status, .pred_Yes) %>%
  autoplot()
```


## Elastic Net 
Lastly, we explore the results of the elastic net model on our test data. First, let's compute its `roc_auc` score and then create visualization as needed. 

### Testing the model 
The elastic net model performed the best out of our top 3 models, with an `roc_auc` score of 0.75. 
```{r}
en_roc_auc <- augment(en_final_fit, new_data = loan_test, type = 'prob') %>%
  roc_auc(Loan_Status, .pred_Yes) %>%
  select(.estimate)

en_roc_auc
```

### ROC curve
Its ROC curve looks much better than that of the KNN model, and is an improvement from the QDA model as well. From approximately 0.5 specificity onward, sensitivity sits near 1.0. This is a good sign! 
```{r}
augment(en_final_fit, new_data = loan_test, type = 'prob') %>%
  roc_curve(Loan_Status, .pred_Yes) %>%
  autoplot()
```


# Conclusion

In this project, we tackled the problem of loan prediction given select demographics specified in applicant profiles. We worked with a relatively small dataset with a large number of features. We tidied the data, performed exploratory analysis, and fit a number of models of varying complexity and flexibility. Through analysis, testing, and assessment, we found the elastic net model to be most optimal for predicting the loan status of an applicant. However, the model was not perfect and leaves room for improvement. 

In fact, none of our models performed particularly well for this problem. This can be due to a variety of factors, such as a violation of assumptions and overfitting. None of the models considered were particularly robust in preventing overfitting (with the exception of elastic net). 

Both the logistic and LDA model assumes a linear decision boundary, are are prone to error in higher dimensions. The Elastic Net (Ridge) model was efficient for variance reduction, but risk increased bias; in our problem, it seemed to have reduced variance to a greater margin, thus decreasing overall error. The QDA model, while an improvement from LDA and Logistic, is not as flexible as KNN or decision tree. For more complex decision boundaries, a non-parametric approach may be preferred. The decision tree is highly variant and also tends to overfit. KNN doesn't require linear separability and makes no distributional assumptions; however, it does not model relationships very well and is also prone to overfitting. 

Given that the QDA and elastic net (Ridge) models performed relatively well on the test set, we can infer that the relationships in our data are non-linear. A potential improvement would be to consider alternative non-linear models or non-linear extensions to some of our models. Another option would be to consider non-parametric approaches. 

As far as our error metric (as measured by `roc_auc`), the elastic net model outperformed the QDA model on the test set, while under-performing on the training set. It is important to note that both models did not have particularly high predictive accuracy (both around 0.7-0.8), likely due to the fact that neither are optimal for dimensional reduction. A more flexible approach, such as a random forest, may be better suitable for our data. Its removal of redundant features and noise would lead to less misleading data and subsequently an improvement in model accuracy.  

It's also good to acknowledge that none of our models performed particularly poorly either. Loan prediction is no easy feat, and predictive models are undoubtedly prone to nuisance factors and noise. In addition, our dataset was incomplete; inclusion of factors such as an applicant's age or race would provide a clearer picture of the company's target demographic and possibly reveal implicit biases in lending. With this understanding, assigning a class label to each applicant based on a select few demographics seem unfair. Instead, applicants should be assessed on a case-by-case basis. 


```{r echo=FALSE, out.width = "100%", fig.align = "center"}
knitr::include_graphics("~/Desktop/School/PSTAT/PSTAT 131/proj-final/images/img03.gif")
```



